// script.js - Liquid Crystal Phase Detection (Debug Version)

let video = document.getElementById("video");
let processBtn = document.getElementById("processBtn");
let canvas = document.getElementById("canvas");
let previewDiv = document.getElementById("preview");
let resultsDiv = document.getElementById("results");
let exportData = [];
let isProcessing = false;

// Phase colors
const phaseColors = {
    'ISOTROPIC': '#2196F3',
    'CHOLESTERIC': '#F44336'
};

// Update status
function updateStatus(message, type = 'info') {
    const statusEl = document.getElementById("status");
    statusEl.textContent = message;
    
    // Color coding
    if (type === 'error') {
        statusEl.style.background = '#fde8e8';
        statusEl.style.color = '#d32f2f';
    } else if (type === 'success') {
        statusEl.style.background = '#e8f5e9';
        statusEl.style.color = '#2e7d32';
    } else if (type === 'warning') {
        statusEl.style.background = '#fff3e0';
        statusEl.style.color = '#f57c00';
    } else {
        statusEl.style.background = '#e3f2fd';
        statusEl.style.color = '#1976d2';
    }
}

// Initialize OpenCV
cv['onRuntimeInitialized'] = () => {
    console.log("‚úÖ OpenCV.js loaded successfully");
    updateStatus("‚úÖ OpenCV.js ready. Select video and click Process.", 'success');
    processBtn.disabled = false;
    
    // Also check if cv object is available
    if (typeof cv === 'undefined') {
        updateStatus("‚ùå OpenCV.js not loaded properly", 'error');
        processBtn.disabled = true;
    }
};

// File selection
document.getElementById("videoFile").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file) {
        // Check file type
        if (!file.type.startsWith('video/')) {
            updateStatus("‚ùå Please select a video file", 'error');
            return;
        }
        
        video.src = URL.createObjectURL(file);
        updateStatus(`üìÅ Video loaded: ${file.name}. Ready to process.`, 'success');
        
        // Enable process button
        processBtn.disabled = false;
    }
});

// Process button click
processBtn.addEventListener("click", async () => {
    if (isProcessing) {
        updateStatus("‚è≥ Already processing, please wait...", 'warning');
        return;
    }
    
    if (!video.src) {
        updateStatus("‚ùå Please select a video file first!", 'error');
        return;
    }
    
    if (typeof cv === 'undefined') {
        updateStatus("‚ùå OpenCV.js not loaded. Please refresh page.", 'error');
        return;
    }
    
    try {
        isProcessing = true;
        processBtn.disabled = true;
        updateStatus("‚è≥ Starting analysis...", 'info');
        
        await processVideo();
        
    } catch (error) {
        console.error("‚ùå Processing error:", error);
        updateStatus(`‚ùå Error: ${error.message}`, 'error');
        isProcessing = false;
        processBtn.disabled = false;
    }
});

// Main processing function
async function processVideo() {
    console.log("Starting video processing...");
    
    // Reset data and UI
    exportData = [];
    previewDiv.innerHTML = "";
    resultsDiv.style.display = "none";
    
    // Set canvas size
    canvas.width = 800;
    canvas.height = 600;
    
    // Wait for video to be ready
    if (video.readyState < 2) {
        updateStatus("‚è≥ Loading video metadata...", 'info');
        await new Promise(resolve => {
            video.onloadedmetadata = resolve;
        });
    }
    
    // Get video properties
    const videoDuration = video.duration || 0;
    const videoWidth = video.videoWidth || 800;
    const videoHeight = video.videoHeight || 600;
    
    console.log(`Video: ${videoWidth}x${videoHeight}, Duration: ${videoDuration}s`);
    
    if (videoDuration === 0) {
        throw new Error("Cannot read video duration. Please try a different video file.");
    }
    
    // Define frames to process (adjust times based on your video)
    // For demo, we'll process frames at specific times
    const framesToProcess = [
        { name: "ISOTROPIC_EXAMPLE", time: 10 },   // Early frame (likely isotropic)
        { name: "CHOLESTERIC_EXAMPLE", time: Math.min(30, videoDuration - 1) }  // Later frame
    ];
    
    updateStatus(`‚è≥ Processing ${framesToProcess.length} frames...`, 'info');
    
    // Process each frame
    for (let i = 0; i < framesToProcess.length; i++) {
        const frameInfo = framesToProcess[i];
        const progress = Math.round(((i + 1) / framesToProcess.length) * 100);
        
        updateStatus(`‚è≥ Processing frame ${i + 1}/${framesToProcess.length} (${progress}%)...`, 'info');
        
        try {
            const result = await processFrameAtTime(frameInfo.time, frameInfo.name);
            if (result) {
                exportData.push(result);
                displayFrameResult(result);
            }
        } catch (frameError) {
            console.warn(`Failed to process frame at ${frameInfo.time}s:`, frameError);
            updateStatus(`‚ö†Ô∏è Skipped frame at ${frameInfo.time}s`, 'warning');
        }
        
        // Small delay between frames
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Show results
    resultsDiv.style.display = "block";
    generateSummary();
    updateStatus(`‚úÖ Analysis complete! Processed ${exportData.length} frames.`, 'success');
    
    isProcessing = false;
    processBtn.disabled = false;
}

// Process frame at specific time
async function processFrameAtTime(timeSeconds, frameName) {
    console.log(`Processing frame at ${timeSeconds}s...`);
    
    // Seek to time
    video.currentTime = timeSeconds;
    
    // Wait for seek to complete
    await new Promise(resolve => {
        const onSeeked = () => {
            video.removeEventListener('seeked', onSeeked);
            setTimeout(resolve, 200); // Extra buffer time
        };
        video.addEventListener('seeked', onSeeked);
    });
    
    // Draw frame on canvas
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    // Process the frame
    const result = await processSingleFrame(canvas, frameName, timeSeconds);
    
    return {
        ...result,
        time: timeSeconds,
        name: frameName
    };
}

// Process a single frame
async function processSingleFrame(canvasElement, frameName, timestamp) {
    console.log(`Processing ${frameName} at ${timestamp}s`);
    
    try {
        // Read image from canvas
        let src = cv.imread(canvasElement);
        
        if (src.empty()) {
            throw new Error("Failed to read image from canvas");
        }
        
        // Convert to grayscale
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        
        // 1. Simple threshold for mask (detect bright areas - electrodes)
        let mask = new cv.Mat();
        cv.threshold(gray, mask, 200, 255, cv.THRESH_BINARY);
        
        // Invert mask (we want to KEEP dark areas, REMOVE bright electrodes)
        cv.bitwise_not(mask, mask);
        
        // 2. Apply mask to grayscale image
        let maskedGray = new cv.Mat();
        cv.bitwise_and(gray, gray, maskedGray, mask);
        
        // 3. Preprocessing
        let blurred = new cv.Mat();
        cv.GaussianBlur(maskedGray, blurred, new cv.Size(5, 5), 0);
        
        let equalized = new cv.Mat();
        cv.equalizeHist(blurred, equalized);
        
        // 4. Threshold for contour detection
        let thresh = new cv.Mat();
        cv.adaptiveThreshold(equalized, thresh, 255, 
                           cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                           cv.THRESH_BINARY_INV, 11, 2);
        
        // Apply mask to threshold result
        let finalThresh = new cv.Mat();
        cv.bitwise_and(thresh, mask, finalThresh);
        
        // 5. Find contours
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(finalThresh, contours, hierarchy, 
                       cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        // 6. Count valid contours
        let validContours = 0;
        for (let i = 0; i < contours.size(); i++) {
            let c = contours.get(i);
            let area = cv.contourArea(c);
            
            // Filter by size (adjust these values based on your needs)
            if (area < 30 || area > 5000) continue;
            
            let peri = cv.arcLength(c, true);
            if (peri === 0) continue;
            
            // Filter by circularity
            let circ = 4 * Math.PI * area / (peri * peri);
            if (circ > 0.2 && circ < 1.2) {
                validContours++;
            }
        }
        
        // 7. Classify
        let phase = classifyPhase(validContours);
        
        console.log(`${frameName}: ${validContours} contours ‚Üí ${phase}`);
        
        // Create visualization with contours
        let displayImg = src.clone();
        if (validContours > 0) {
            cv.drawContours(displayImg, contours, -1, [0, 255, 0, 255], 2);
        }
        
        // Cleanup
        gray.delete();
        mask.delete();
        maskedGray.delete();
        blurred.delete();
        equalized.delete();
        thresh.delete();
        finalThresh.delete();
        hierarchy.delete();
        contours.delete();
        
        return {
            src: src,
            display: displayImg,
            processed: equalized.clone(),
            thresh: finalThresh.clone(),
            validContours: validContours,
            phase: phase
        };
        
    } catch (error) {
        console.error("Error in processSingleFrame:", error);
        throw error;
    }
}

// Simple classification
function classifyPhase(contourCount) {
    // Simple rule: 0 contours = isotropic, >0 contours = cholesteric
    return contourCount === 0 ? "ISOTROPIC" : "CHOLESTERIC";
}

// Display frame results
function displayFrameResult(result) {
    const frameDiv = document.createElement("div");
    frameDiv.className = "frame-result";
    frameDiv.style.border = `3px solid ${phaseColors[result.phase]}`;
    frameDiv.style.padding = "15px";
    frameDiv.style.margin = "10px 0";
    frameDiv.style.borderRadius = "10px";
    frameDiv.style.background = "white";
    
    // Convert mats to canvases
    const srcCanvas = matToCanvas(result.src, "Original Frame");
    const procCanvas = matToCanvas(result.processed, "Preprocessed");
    const threshCanvas = matToCanvas(result.thresh, `Threshold (${result.validContours} contours)`);
    const displayCanvas = matToCanvas(result.display, "Result with Contours");
    
    frameDiv.innerHTML = `
        <h3 style="color: ${phaseColors[result.phase]}; margin-top: 0;">
            ${result.phase} Phase (${result.validContours} contours)
        </h3>
        <div style="color: #666; margin-bottom: 15px;">
            Time: ${result.time.toFixed(1)}s
        </div>
        
        <div class="frame-images" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
            <div style="flex: 1; min-width: 200px; text-align: center;">
                <h4 style="margin: 5px 0; color: #555;">Original</h4>
                ${srcCanvas.outerHTML}
            </div>
            <div style="flex: 1; min-width: 200px; text-align: center;">
                <h4 style="margin: 5px 0; color: #555;">Preprocessed</h4>
                ${procCanvas.outerHTML}
            </div>
        </div>
        
        <div class="frame-images" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-top: 15px;">
            <div style="flex: 1; min-width: 200px; text-align: center;">
                <h4 style="margin: 5px 0; color: #555;">Threshold</h4>
                ${threshCanvas.outerHTML}
            </div>
            <div style="flex: 1; min-width: 200px; text-align: center;">
                <h4 style="margin: 5px 0; color: #555;">Result</h4>
                ${displayCanvas.outerHTML}
            </div>
        </div>
        
        <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
            <p style="margin: 5px 0;"><strong>Contours found:</strong> ${result.validContours}</p>
            <p style="margin: 5px 0;"><strong>Classification:</strong> 
                <span style="color: ${phaseColors[result.phase]}; font-weight: bold;">
                    ${result.phase}
                </span>
            </p>
            <p style="margin: 5px 0; font-size: 0.9em; color: #666;">
                Rule: ${result.validContours === 0 ? 
                       "0 contours = ISOTROPIC" : 
                       `${result.validContours} contours = CHOLESTERIC`}
            </p>
        </div>
    `;
    
    previewDiv.appendChild(frameDiv);
    
    // Cleanup
    result.src.delete();
    result.display.delete();
    result.processed.delete();
    result.thresh.delete();
}

// Convert OpenCV Mat to Canvas
function matToCanvas(mat, title = "") {
    const canvas = document.createElement("canvas");
    canvas.width = mat.cols;
    canvas.height = mat.rows;
    
    // Convert to RGBA if needed
    let displayMat = mat.clone();
    if (mat.type() === cv.CV_8UC1) {
        cv.cvtColor(mat, displayMat, cv.COLOR_GRAY2RGBA);
    } else if (mat.type() === cv.CV_8UC3) {
        cv.cvtColor(mat, displayMat, cv.COLOR_RGB2RGBA);
    }
    
    cv.imshow(canvas, displayMat);
    displayMat.delete();
    
    canvas.style.border = "1px solid #ddd";
    canvas.style.borderRadius = "5px";
    canvas.style.maxWidth = "100%";
    canvas.style.height = "auto";
    
    if (title) {
        canvas.title = title;
    }
    
    return canvas;
}

// Generate summary
function generateSummary() {
    const summaryDiv = document.getElementById("summary");
    summaryDiv.innerHTML = "";
    
    if (exportData.length === 0) {
        summaryDiv.innerHTML = "<p>No data to display.</p>";
        return;
    }
    
    let html = `<h3 style="margin-top: 0;">üìã Analysis Summary</h3>`;
    html += `<p><strong>Classification Rule:</strong><br>`;
    html += `‚Ä¢ 0 contours ‚Üí ISOTROPIC phase<br>`;
    html += `‚Ä¢ >0 contours ‚Üí CHOLESTERIC phase</p>`;
    
    html += `<table class="summary-table" style="width: 100%; border-collapse: collapse; margin-top: 15px;">
        <tr style="background: #007bff; color: white;">
            <th style="padding: 10px; border: 1px solid #ddd;">Frame</th>
            <th style="padding: 10px; border: 1px solid #ddd;">Time (s)</th>
            <th style="padding: 10px; border: 1px solid #ddd;">Contours</th>
            <th style="padding: 10px; border: 1px solid #ddd;">Phase</th>
        </tr>`;
    
    exportData.forEach((result, index) => {
        html += `<tr style="${index % 2 === 0 ? 'background: #f8f9fa;' : ''}">
            <td style="padding: 10px; border: 1px solid #ddd;">Frame ${index + 1}</td>
            <td style="padding: 10px; border: 1px solid #ddd;">${result.time.toFixed(1)}</td>
            <td style="padding: 10px; border: 1px solid #ddd;">${result.validContours}</td>
            <td style="padding: 10px; border: 1px solid #ddd; color: ${phaseColors[result.phase]}; font-weight: bold;">
                ${result.phase}
            </td>
        </tr>`;
    });
    
    html += `</table>`;
    
    summaryDiv.innerHTML = html;
}

// Export to CSV
document.getElementById("downloadBtn").addEventListener("click", () => {
    if (exportData.length === 0) {
        alert("No data to export. Please process video first.");
        return;
    }
    
    let csv = "frame,time_seconds,contours,phase\n";
    exportData.forEach((result, index) => {
        csv += `Frame ${index + 1},${result.time},${result.validContours},${result.phase}\n`;
    });
    
    // Create download link
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "liquid_crystal_analysis.csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    updateStatus("‚úÖ CSV file downloaded", 'success');
});

// Code tab switching
function showCode(language) {
    // Remove active class from all buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Hide all code blocks
    document.querySelectorAll('.code-container > div').forEach(div => {
        div.classList.add('hidden');
    });
    
    // Activate selected button and show code
    document.querySelector(`[onclick="showCode('${language}')"]`).classList.add('active');
    document.getElementById(`${language}-code`).classList.remove('hidden');
}
